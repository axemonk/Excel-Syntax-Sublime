%YAML 1.2
---
name: Excel formula
# Made by Alco#0424 and [Q4]Fry#2960
# Repo: https://github.com/axemonk/Excel-formula
# Please send any bug reports and suggestions to Alco#0424 via a direct message on Discord.
# You can find me on the official Sublime Text Discord server.
# v2.0.0 4/30/2023
file_extensions: []
scope: source.excel
version: 2

contexts:
  immediately-pop:
    - match: ''
      pop: 1

  # # Didn't turn out to need one of these
  # else-pop:
  #   - match: (?=\S)
  #     pop: 1

  main:
    # Matches assignment operator '='
    - match: ^=
      scope: keyword.operator.assignment.excel

    # The weird text-qualifier Excel has? Pretend that's a comment
    - match: ^\'
      scope: punctuation.definition.comment.begin.excel
      # scope: punctuation.definition.string.begin.excel
      push:
        - meta_scope: comment.line.single-quote.excel
        # - meta_scope: string.unquoted.excel
        - match: $
          pop: 1

    - include: expressions

    # Sanity checks
    # TODO: replicate this feature for stray end square and curly brackets
    #       (neither work inside parentheticals)
    - match: '[)}\]]'
      scope: invalid.illegal.stray-bracket-end.excel


  expressions:
    - include: function-calls
    - include: operators
    - include: references
    - include: constants
    - include: arrays
    - include: groups
    # Very speculative
    - match: \w+
      scope: variable.other.readwrite.excel
    - match: \t
      scope: invalid.illegal.excel


  function-calls:
    # # Included as a "support." function in line with convention in that
    # # the vast majority of functions in Excel are provided by what I would consider the 'Excel framework'.
    # # TODO?: The exception being user-defined lambda functions
    # # (soln?: check to see if a word before a '(' is not in the list of all Excel functions) (prblm: will easily deprecate and is likely very slow)

    # # Can't decide whether to do things like this or not.
    # - match: \b((?i:(?:COUNT|SUM)?IF))(\()
    #   captures:
    #     1: meta.function-call.excel keyword.control.conditional.if.excel
    #     2: meta.function-call.arguments.excel punctuation.section.arguments.begin.excel
    #   push: function-call-body

    # # TODO: How do you know when the assignment part of LET is over?
    # - match: \b((?:LET))(\()
    #   captures:
    #     1: meta.function-call.excel keyword.declaration.excel
    #     2: meta.function-call.arguments.excel punctuation.section.arguments.begin.excel
    #   push: [let-declarations-body, function-call-body]

    # TODO: LAMBDA, maybe?

    - match: \b([A-Za-z\.]+)(\()
      captures:
        1: meta.function-call.excel support.function.excel
        2: meta.function-call.arguments.excel punctuation.section.arguments.begin.excel
      push: function-call-body

  function-call-body:
    - meta_content_scope: meta.function-call.arguments.excel
    - match: \)
      scope: meta.function-call.arguments.excel punctuation.section.arguments.end.excel
      pop: 1
    - match: \,
      scope: punctuation.separator.sequence.excel
    - include: expressions

  let-declarations-body:
    # BUG: I disabled LET special behavior, because I can't tell how to know
    #   where it stops assigning variables and starts calculating.
    # If you see a function call, pop to normal function call from declaration
    - match: (?=[A-Za-z\.]+\()
      pop: 1
    - include: references
    - match: \w+
      scope: variable.other.readwrite.excel


  arrays:
    - match: \{
      scope: punctuation.section.braces.begin.excel
      push: array-body

  array-body:
    - meta_scope: meta.array.excel
    - match: \}
      scope: punctuation.section.braces.end.excel
      pop: 1
    - match: \,
      scope: punctuation.separator.sequence.column.excel
    - match: ;
      scope: punctuation.separator.sequence.row.excel
    - include: expressions


  groups:
    - match: \(
      scope: punctuation.section.group.begin.excel
      push: group-body

  group-body:
    - meta_scope: meta.group.excel
    - match: \)
      scope: punctuation.section.group.end.excel
      pop: 1
    - include: expressions


  operators:
    # Matches logical operator (e.g., 'A1 = B2')
    - match: =
      scope: keyword.operator.logical.excel

    # Matches mathematical operators
    - match: '[+\-*/^%]'
      scope: keyword.operator.arithmetic.excel

    - match: \&
      scope: keyword.operator.concatenation.excel


  sheet-reference:
    - match: (?=(?:[A-Za-z0-9_]+|'.+')+!)
      push: [cell-or-range-reference-body, sheet-reference-body]

  sheet-reference-body:
    - match: \!
      scope: punctuation.separator.sequence.excel
      pop: 1
    - match: (')
      scope: punctuation.definition.annotation.begin.excel
      push:
        - meta_scope: entity.name.struct.excel
        - match: (')
          scope: punctuation.definition.annotation.end.excel
          pop: 1
    - match: '[A-Za-z0-9_]+'
      scope: entity.name.struct.excel
    - include: immediately-pop


  cell-or-range-reference:
    - match: (?=\$?[a-zA-Z]+\$?[0-9]+)
      push: cell-or-range-reference-body

  cell-or-range-reference-body:
    - meta_scope: meta.reference.excel

    # Matches A1:B2 format 'cell:cell' references
    - match: (\$?[a-zA-Z]+\$?[0-9]+)(:)(\$?([a-zA-Z]+\$?[0-9]+\$?)?)
      # scope: meta.reference.excel
      captures:
        1: storage.type.excel
        2: punctuation.separator.sequence.excel
        3: storage.type.excel
      pop: 1

    # Matches A1 format 'cell' references
    - match: \$?[a-zA-Z]+\$?[0-9]+
      scope: storage.type.excel
      pop: 1

    # Bail if nothing matches
    - include: immediately-pop


  table-name:
    # Matches table name references
    - match: ([A-Za-z0-9._?\\]+)?(\[)
      captures:
        1: entity.name.struct.excel
        2: punctuation.section.brackets.begin.excel
      push: table-name-body

  table-name-body:
    - meta_scope: meta.reference.excel

    # CHANGE: Along with change to 'Anything that shouldn't match',
    # the second group ensures commas and colons can still be used in column names
    # without mismatching them elsewhere
    - match: (\])([,:])?
      captures:
        1: punctuation.section.brackets.end.excel
        2: punctuation.separator.sequence.excel
      pop: 1

    # CHANGE: Matches escaped brackets and operators and prevents conflict between
    # brackets and ,:
    - match: ([,:]*\'[\]\[@#][,:]*)
      scope: storage.type.excel

    - match: '[#@]'
      scope: keyword.operator.reference.excel

    - match: \[
      scope: punctuation.section.brackets.begin.excel
      push: table-name-body

    # Anything that should't match but could otherwise be within the body
    # Technically, we could do `.`, but that slows down tokenization
    # CHANGE: Removed ,:
    - match: '[^#@\[\]]+'
      scope: storage.type.excel

  references:
    # # These four were tricky when reworking the scopes to be in line with convention.
    # #
    # # I tried to balance actually having them colored differently in the default sublime color scheme,
    # # as is helpful to have in a tightly-packed Excel formula, while at the same time
    # # having the scope names align with what these various references represent from a code perspective.
    # #
    # # This proved to be *very* difficult for cell and column references (see cop-out: storage.type.excel),
    # # but for sheet and table name references, .struct. seems to fit well under the definition:
    # #
    # # # struct: "a composite data type (or record) declaration that defines a physically grouped list of variables
    # # #          under one name in a block of memory"

    - include: table-name
    - include: sheet-reference
    - include: cell-or-range-reference


  constants:
    - match: \b(?i:TRUE|FALSE)\b
      scope: constant.language.boolean.excel
    - include: numbers
    - include: strings

  numbers:
    - match: '-?[0-9]+(?:\.\d+)?'
      scope: constant.numeric.excel

  strings:
    - match: '"'
      scope: punctuation.definition.string.begin.excel
      push: string-body

  string-body:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.excel
    - match: '""'
      scope: constant.character.escape.excel
    - match: '"'
      scope: punctuation.definition.string.end.excel
      pop: 1
    # CHANGE: Tilde escapes wildcards and itself, but can also be used by itself and function as a literal
    - match: '(~)([*?~])'
      captures:
        1: keyword.operator.wildcard.escape.excel
        2: string.quoted.double.excel
    # Not technically applicable to all strings, but probably fine, yes?
    # I'd say so. Possible future functionality?
    - match: '[*?]'
      scope: keyword.operator.wildcard.excel

  # TODO: Not all functions allow wildcards. Here is a list of the most common functions that do:

  # AVERAGEIF, AVERAGEIFS
  # COUNTIF, COUNTIFS
  # MAXIFS, MINIFS
  # SUMIF, SUMIFS
  # VLOOKUP, HLOOKUP
  # MATCH
  # SEARCH
